# 連行移動荷重リファクタリング計画書

## 1. 概要

本計画書は、連行移動荷重（LL: Linear Load）機能のリファクタリングについて記載しています。
現状のコードでは連行移動荷重の処理が複数のサービスに分散しており、責務の分離が明確でないため、
コードの保守性と拡張性を向上させることを目的としています。

## 2. 現状の問題点

現在の連行移動荷重機能には以下の問題点があります：

1. **コードの分散**
   - 連行移動荷重の処理が複数のサービスに分散している
   - 機能が特定のクラスに集約されておらず、既存のサービス内に混在している
   - 特に、表示処理が `ThreeLoadService` と `ThreeDisplacementService` の両方に実装されている
   - 位置計算（`get_LL_position`）が `InputLoadService` に埋め込まれている

2. **データ構造の不明確さ**
   - 連行移動荷重のデータ構造が明確に型定義されていない
   - `any` 型が多用されており、型安全性が低い
   - `load_name` オブジェクトに `LL_pitch` プロパティが含まれているが、連行移動荷重専用のモデルとの関係が明確でない
   - `LoadColumns` 型と連行移動荷重の関係が不明確

3. **パフォーマンスの問題**
   - 連行移動荷重計算時に毎回全ての荷重を削除して再作成している（`change_LL_Load` メソッド）
   - 大量の荷重ケースを生成するとパフォーマンスが低下する可能性がある
   - アニメーション処理が効率的に実装されていない（10フレームに1回の更新）

4. **テスト困難性**
   - 機能が複数のサービスに分散しているため、単体テストが困難
   - 依存関係が複雑で結合度が高い

5. **シンボル判定処理の重複**
   - 連行移動荷重の識別が `symbol.includes("LL")` のような文字列判定で複数箇所に分散している
   - `checkLL` メソッドが `InputLoadComponent` にのみ実装されている
   - 判定方法が統一されておらず、変更時の影響範囲が広い

6. **三次元表示システムとの連携が複雑**
   - 連行移動荷重の表示処理が複数のサービスに分散している
   - アニメーション処理が `ThreeLoadService` と `ThreeDisplacementService` で異なる実装
   - フレーム制御とレンダリングタイミングが統一されていない

7. **UI設計の課題**
   - 連行移動荷重のピッチ設定UIが荷重入力画面に直接埋め込まれている
   - `change_pich` メソッドの命名が不適切（typo）
   - 連行移動荷重専用のコンポーネント化が不十分

## 3. リファクタリング提案

### 3.1 クラス分割と責務の明確化

- 連行移動荷重専用の新しいサービスクラス `LLLoadService` を作成し、関連ロジックを集約する
- 既存のサービスから連行移動荷重関連のメソッドを移動させる

```typescript
// src/app/components/input/input-load/ll-load.service.ts を新規作成
import { Injectable } from "@angular/core";
import { InputMembersService } from "../input-members/input-members.service";
import { DataHelperModule } from "../../../providers/data-helper.module";

@Injectable({
  providedIn: "root",
})
export class LLLoadService {
  constructor(
    private member: InputMembersService,
    private helper: DataHelperModule
  ) {}

  // InputLoadServiceから移動させるメソッド
  public calculateLLPosition(loads: LLLoad[]): LLPositionResult {
    // 既存のget_LL_positionメソッドを型安全に改善
    // 荷重の長さ(L1)計算
    let startPosition = 0;
    for (const load of loads) {
      const L1 = this.helper.toNumber(load.L1);
      if (L1 <= 0) startPosition -= L1;
      if (load.L2 <= 0) startPosition -= load.L2;
    }

    // 載荷する部材の長さ(L2)計算
    let totalLength = 0;
    const m1 = Math.abs(parseInt(loads[0].m1));
    let m2 = Math.abs(parseInt(loads[0].m2));
    if (m2 === 0) m2 = m1;
    
    for (let j = m1; j <= m2; j++) {
      totalLength += Math.round(this.member.getMemberLength(j.toString()) * 1000);
    }
    
    return {
      startPosition: -startPosition,
      totalLength: totalLength / 1000
    };
  }

  // ThreeLoadServiceから移動させるメソッド
  public generateLLLoadCases(caseId: string, pitch: number, loads: LLLoad[]): LLLoadCase[] {
    // 既存のchange_LL_Loadメソッドのロジックを改善
    const position = this.calculateLLPosition(loads);
    const maxLength = position.totalLength + Math.abs(position.startPosition);
    const count = Math.round(maxLength / pitch * 10) / 10;
    
    const loadCases: LLLoadCase[] = [];
    for (let i = 0; i <= count; i++) {
      const offset = Math.round(i * pitch * 1000) / 1000;
      loadCases.push({
        caseId: i === 0 ? caseId : `${caseId}.${i}`,
        position: offset,
        loads: this.adjustLoadPositions(loads, offset)
      });
    }
    
    return loadCases;
  }

  // シンボル判定メソッドを集約
  public isLLLoad(symbol: string): boolean {
    return symbol?.includes("LL") ?? false;
  }

  // ピッチ値の検証
  public validatePitch(pitch: number): number {
    return Math.max(pitch, 0.1);
  }

  private adjustLoadPositions(loads: LLLoad[], offset: number): LLLoad[] {
    // L1値を調整した荷重データを生成
    return loads.map((load, index) => ({
      ...load,
      L1: index === 0 ? (parseFloat(load.L1) + offset).toFixed(3) : load.L1
    }));
  }
}
```

### 3.2 データ構造の改善

- 連行移動荷重に関する型定義を作成する
- データ構造をより明示的に定義する
- 既存の`load_name`オブジェクトと`LoadColumns`型との互換性を確保する

```typescript
// src/app/components/input/input-load/ll-load.types.ts を新規作成

// 既存のLoadColumns型を拡張した連行移動荷重用の型
export interface LLLoad extends Omit<LoadColumns, 'L1' | 'L2' | 'P1' | 'P2'> {
  m1: string;
  m2: string;
  direction: string;
  mark: string;
  L1: string;      // 文字列として保持（既存の実装に合わせる）
  L2: string;
  P1: string;
  P2: string;
  row: number;
}

// 連行移動荷重の設定情報
export interface LLLoadConfiguration {
  caseId: string;
  symbol: string;
  pitch: number;        // 既存のload_name.LL_pitchに対応
  isActive: boolean;    // 連行移動荷重として有効かどうか
}

// 連行移動荷重のケース情報
export interface LLLoadCase {
  caseId: string;       // "1", "1.1", "1.2" などの形式
  position: number;     // 荷重の位置（オフセット）
  loads: LLLoad[];      // 調整された荷重データ
}

// 連行移動荷重の定義全体
export interface LLLoadDefinition {
  configuration: LLLoadConfiguration;
  originalLoads: LLLoad[];     // 元の荷重データ
  generatedCases: LLLoadCase[]; // 生成された荷重ケース
  positionInfo: LLPositionResult;
}

// 位置計算結果の型定義（既存の戻り値に合わせて改名）
export interface LLPositionResult {
  startPosition: number;  // スタート位置（旧L1）
  totalLength: number;    // 最大長さ（旧LL_length）
}

// 荷重生成結果の型定義
export interface LLLoadGenerationResult {
  loadCases: string[];    // 生成されたケースID一覧
  memberKeys: string[];   // 関連する部材キー
  maxLoadValues: { [key: string]: number }; // 最大荷重値
}

// 既存のload_name構造との互換性を保つための型
export interface LoadNameWithLL {
  id: string;
  rate: string;
  symbol: string;
  name: string;
  fix_node: string;
  fix_member: string;
  element: string;
  joint: string;
  LL_pitch: number;     // 連行移動荷重のピッチ
}

// アニメーション制御用の型
export interface LLAnimationState {
  isActive: boolean;
  currentCaseIndex: number;
  totalCases: number;
  frameRate: number;
  updateInterval: number;
}
```

### 3.3 アニメーション処理の改善

- アニメーション処理を独立したクラスに分離する
- RxJSの利用でアニメーションをストリーム処理として実装する
- ThreeLoadServiceとThreeDisplacementServiceのアニメーション処理を統一する

```typescript
// src/app/components/three/geometry/ll-animation.service.ts を新規作成
import { Injectable } from "@angular/core";
import { Observable, BehaviorSubject, timer, EMPTY } from "rxjs";
import { map, takeWhile, tap, finalize } from "rxjs/operators";
import { LLAnimationState } from "../../input/input-load/ll-load.types";

@Injectable({
  providedIn: "root",
})
export class LLAnimationService {
  private animationState: LLAnimationState = {
    isActive: false,
    currentCaseIndex: 0,
    totalCases: 0,
    frameRate: 30,
    updateInterval: 10  // 10フレームに1回更新（既存の実装に合わせる）
  };

  private animationSubject = new BehaviorSubject<LLAnimationState>(this.animationState);
  private animationHandle: number | undefined;

  public get currentState$(): Observable<LLAnimationState> {
    return this.animationSubject.asObservable();
  }

  /**
   * 連行移動荷重のアニメーションを開始
   * @param loadCases 荷重ケース一覧
   * @param renderCallback レンダリングコールバック関数
   * @param frameRate フレームレート（デフォルト30fps）
   */
  public startAnimation(
    loadCases: string[],
    renderCallback: (caseId: string, index: number) => void,
    frameRate: number = 30
  ): Observable<string> {
    if (loadCases.length === 0) {
      return EMPTY;
    }

    this.stopAnimation(); // 既存のアニメーションを停止

    this.animationState = {
      isActive: true,
      currentCaseIndex: 0,
      totalCases: loadCases.length,
      frameRate,
      updateInterval: 10
    };

    let frameCount = 0;
    let lastCaseIndex = -1;

    return timer(0, 1000 / frameRate).pipe(
      map(() => {
        frameCount++;
        const caseIndex = Math.floor(frameCount / this.animationState.updateInterval) % loadCases.length;
        
        if (caseIndex !== lastCaseIndex) {
          this.animationState.currentCaseIndex = caseIndex;
          this.animationSubject.next({ ...this.animationState });
          renderCallback(loadCases[caseIndex], caseIndex);
          lastCaseIndex = caseIndex;
        }
        
        return loadCases[caseIndex];
      }),
      takeWhile(() => this.animationState.isActive),
      finalize(() => {
        this.animationState.isActive = false;
        this.animationSubject.next({ ...this.animationState });
      })
    );
  }

  /**
   * requestAnimationFrameを使用した従来型アニメーション（既存コードとの互換性のため）
   */
  public startLegacyAnimation(
    keys: string[],
    renderCallback: (key: string, index: number) => void,
    i: number = 0,
    oldIndex: number = 0
  ): void {
    this.stopAnimation();

    const animate = () => {
      let currentIndex = Math.floor(i / this.animationState.updateInterval);
      
      if (currentIndex < keys.length) {
        i++;
      } else {
        i = 0;
        currentIndex = 0;
      }

      this.animationHandle = requestAnimationFrame(() => {
        this.startLegacyAnimation(keys, renderCallback, i, currentIndex);
      });

      if (currentIndex !== oldIndex) {
        this.animationState.currentCaseIndex = currentIndex;
        this.animationSubject.next({ ...this.animationState });
        renderCallback(keys[currentIndex], currentIndex);
      }
    };

    this.animationState.isActive = true;
    this.animationState.totalCases = keys.length;
    animate();
  }

  public stopAnimation(): void {
    this.animationState.isActive = false;
    this.animationSubject.next({ ...this.animationState });
    
    if (this.animationHandle !== undefined) {
      cancelAnimationFrame(this.animationHandle);
      this.animationHandle = undefined;
    }
  }

  public pauseAnimation(): void {
    this.animationState.isActive = false;
    this.animationSubject.next({ ...this.animationState });
  }

  public resumeAnimation(): void {
    this.animationState.isActive = true;
    this.animationSubject.next({ ...this.animationState });
  }

  public setFrameRate(frameRate: number): void {
    this.animationState.frameRate = Math.max(1, Math.min(60, frameRate));
    this.animationSubject.next({ ...this.animationState });
  }

  public setUpdateInterval(interval: number): void {
    this.animationState.updateInterval = Math.max(1, interval);
    this.animationSubject.next({ ...this.animationState });
  }
}
```

### 3.4 連行移動荷重のUI改善

- 既存の機能（ピッチ設定のみ）を維持しながら、コードを整理する
- 連行移動荷重設定部分をコンポーネント化して再利用性を高める
- 入力バリデーション処理を統一し、命名規則を改善する

```typescript
// src/app/components/input/input-ll-load/input-ll-load.component.ts
import { Component, OnInit, Input, Output, EventEmitter, OnDestroy } from '@angular/core';
import { LLLoadService } from '../input-load/ll-load.service';
import { LLAnimationService } from '../../three/geometry/ll-animation.service';
import { LLLoadConfiguration, LLAnimationState } from '../input-load/ll-load.types';
import { Subscription } from 'rxjs';

@Component({
  selector: "app-input-ll-load",
  templateUrl: "./input-ll-load.component.html",
  styleUrls: ["./input-ll-load.component.scss"],
})
export class InputLLLoadComponent implements OnInit, OnDestroy {
  @Input() configuration: LLLoadConfiguration;
  @Output() configurationChange = new EventEmitter<LLLoadConfiguration>();
  @Output() pitchChange = new EventEmitter<number>();

  public animationState: LLAnimationState;
  private subscription: Subscription;

  constructor(
    private llLoadService: LLLoadService,
    private animationService: LLAnimationService
  ) {}

  ngOnInit(): void {
    this.subscription = this.animationService.currentState$.subscribe(
      state => this.animationState = state
    );
  }

  ngOnDestroy(): void {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }

  /**
   * ピッチ変更時の処理（change_pichメソッドの改善版）
   */
  onPitchChange(): void {
    const validatedPitch = this.llLoadService.validatePitch(this.configuration.pitch);
    
    if (this.configuration.pitch !== validatedPitch) {
      this.configuration.pitch = validatedPitch;
    }

    this.configurationChange.emit(this.configuration);
    this.pitchChange.emit(this.configuration.pitch);
  }

  /**
   * 連行移動荷重の有効/無効切り替え
   */
  onActiveChange(): void {
    this.configurationChange.emit(this.configuration);
  }

  /**
   * シンボル判定（既存のcheckLLメソッドの改善版）
   */
  public isLLLoadActive(symbol: string): boolean {
    return this.llLoadService.isLLLoad(symbol);
  }

  /**
   * アニメーション制御
   */
  public toggleAnimation(): void {
    if (this.animationState.isActive) {
      this.animationService.pauseAnimation();
    } else {
      this.animationService.resumeAnimation();
    }
  }

  public stopAnimation(): void {
    this.animationService.stopAnimation();
  }

  /**
   * ピッチ値の表示用フォーマット
   */
  public formatPitch(value: number): string {
    return value.toFixed(1);
  }
}
```

```html
<!-- src/app/components/input/input-ll-load/input-ll-load.component.html -->
<div class="ll-load-container" *ngIf="configuration?.isActive">
  <div class="ll-load-header">
    <label class="label">連行荷重（β版）</label>
    <div class="animation-controls" *ngIf="animationState?.totalCases > 0">
      <button 
        type="button" 
        class="btn btn-sm"
        [class.btn-primary]="!animationState.isActive"
        [class.btn-secondary]="animationState.isActive"
        (click)="toggleAnimation()">
        {{ animationState.isActive ? '一時停止' : '再生' }}
      </button>
      <button 
        type="button" 
        class="btn btn-sm btn-outline-secondary"
        (click)="stopAnimation()">
        停止
      </button>
      <span class="animation-info">
        {{ animationState.currentCaseIndex + 1 }} / {{ animationState.totalCases }}
      </span>
    </div>
  </div>
  
  <div class="ll-load-settings">
    <div class="pitch-setting">
      <label class="label">ピッチ</label>
      <input 
        type="number" 
        min="0.1" 
        step="0.1" 
        class="form-control form-control-sm pitch-input"
        [(ngModel)]="configuration.pitch"
        (change)="onPitchChange()"
        [title]="'現在の値: ' + formatPitch(configuration.pitch) + 'm'">
      <label class="label">m</label>
    </div>
    
    <div class="ll-load-info">
      <small class="text-muted">
        ケースID: {{ configuration.caseId }} | 
        シンボル: {{ configuration.symbol }}
      </small>
    </div>
  </div>
</div>
```

```scss
/* src/app/components/input/input-ll-load/input-ll-load.component.scss */
.ll-load-container {
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 0.375rem;
  padding: 0.75rem;
  margin-bottom: 1rem;

  .ll-load-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;

    .label {
      font-weight: 600;
      color: #495057;
      margin: 0;
    }

    .animation-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;

      .animation-info {
        font-size: 0.875rem;
        color: #6c757d;
      }
    }
  }

  .ll-load-settings {
    .pitch-setting {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;

      .pitch-input {
        width: 80px;
      }

      .label {
        margin: 0;
        font-size: 0.875rem;
      }
    }

    .ll-load-info {
      font-size: 0.75rem;
    }
  }
}
```

### 3.5 パフォーマンス最適化

- オブジェクトプーリングを実装して、Three.jsのオブジェクト生成・破棄を最小限に抑える
- 必要な部分のみ更新する差分更新方式を採用する
- 計算結果のキャッシュ機能を追加する

```typescript
// オブジェクトプーリングの実装例
class LoadObjectPool {
  private pool: Map<string, THREE.Object3D[]> = new Map();

  public getObject(type: string): THREE.Object3D {
    if (!this.pool.has(type)) {
      this.pool.set(type, []);
    }
    
    const objects = this.pool.get(type);
    if (objects.length > 0) {
      return objects.pop();
    } else {
      return this.createNewObject(type);
    }
  }

  public returnObject(type: string, object: THREE.Object3D): void {
    object.visible = false;
    if (!this.pool.has(type)) {
      this.pool.set(type, []);
    }
    this.pool.get(type).push(object);
  }

  private createNewObject(type: string): THREE.Object3D {
    // 種類に応じたオブジェクト生成ロジック
    // ...
  }
}
```

### 3.5 三次元表示システムとの連携改善

- `ThreeLoadService` と `ThreeDisplacementService` の連行移動荷重処理を統一する
- アニメーション処理を `LLAnimationService` に委譲する
- レンダリング処理の最適化とオブジェクトプーリングの実装

```typescript
// src/app/components/three/geometry/ll-three-integration.service.ts を新規作成
import { Injectable } from '@angular/core';
import { LLLoadService } from '../../input/input-load/ll-load.service';
import { LLAnimationService } from './ll-animation.service';
import { ThreeLoadService } from './three-load/three-load.service';
import { ThreeDisplacementService } from './three-displacement.service';

@Injectable({
  providedIn: 'root'
})
export class LLThreeIntegrationService {
  constructor(
    private llLoadService: LLLoadService,
    private animationService: LLAnimationService,
    private threeLoadService: ThreeLoadService,
    private threeDisplacementService: ThreeDisplacementService
  ) {}

  /**
   * 連行移動荷重の三次元表示を更新（ThreeLoadServiceの処理を統合）
   */
  public updateLLLoadDisplay(caseId: string): void {
    if (!this.llLoadService.isLLLoad(this.getSymbolForCase(caseId))) {
      return;
    }

    const memberLoadData = this.getMemberLoadData(caseId);
    const llKeys = Object.keys(memberLoadData);

    // 既存の連行移動荷重表示を削除
    this.removeLLLoadCases(caseId);

    // 新しい連行移動荷重を生成・表示
    this.createLLLoadCases(llKeys, memberLoadData);

    // アニメーション開始
    this.startLLAnimation(llKeys, memberLoadData);
  }

  /**
   * 連行移動荷重の変位表示を更新（ThreeDisplacementServiceの処理を統合）
   */
  public updateLLDisplacementDisplay(
    caseId: string, 
    memberKeys: string[], 
    minDistance: number, 
    maxDistance: number
  ): void {
    const llKeys = this.getLLKeysForCase(caseId);
    if (llKeys.length === 0) return;

    // アニメーション開始
    this.startLLDisplacementAnimation(llKeys, memberKeys, minDistance, maxDistance);
  }

  private startLLAnimation(keys: string[], data: any): void {
    this.animationService.startLegacyAnimation(
      keys,
      (key: string, index: number) => {
        this.threeLoadService.visibleCaseChange(key, true);
        this.threeLoadService.scene.render();
      }
    );
  }

  private startLLDisplacementAnimation(
    keys: string[], 
    memberKeys: string[], 
    minDistance: number, 
    maxDistance: number
  ): void {
    this.animationService.startLegacyAnimation(
      keys,
      (key: string, index: number) => {
        this.threeDisplacementService.changeDisg(key, memberKeys, minDistance, maxDistance);
        this.threeDisplacementService.scene.render();
      }
    );
  }

  // ヘルパーメソッド
  private getSymbolForCase(caseId: string): string {
    // 実装詳細は省略
    return '';
  }

  private getMemberLoadData(caseId: string): any {
    // 実装詳細は省略
    return {};
  }

  private getLLKeysForCase(caseId: string): string[] {
    // 実装詳細は省略
    return [];
  }

  private removeLLLoadCases(caseId: string): void {
    // 実装詳細は省略
  }

  private createLLLoadCases(keys: string[], data: any): void {
    // 実装詳細は省略
  }
}
```

### 3.6 位置計算処理の改善

- `input-load.service.ts`の`get_LL_position`メソッドを最適化する
- 荷重の長さ(L1)と載荷する部材の長さ(L2)の計算を明確に分離する
- 計算結果のキャッシュ機能を追加する

```typescript
export class LLLoadService {
  private positionCache = new Map<string, LLPositionResult>();

  // InputLoadServiceのget_LL_positionメソッドを改善
  public calculateLLPosition(loads: LLLoad[]): LLPositionResult {
    // キャッシュキーの生成
    const cacheKey = this.generateCacheKey(loads);
    
    // キャッシュから結果を取得
    if (this.positionCache.has(cacheKey)) {
      return this.positionCache.get(cacheKey)!;
    }

    // L1の計算部分（荷重のスタート位置）
    const calculateStartPosition = (loads: LLLoad[]): number => {
      let startPosition = 0;
      for (const load of loads) {
        const L1 = this.helper.toNumber(load.L1);
        if (L1 <= 0) {
          startPosition -= L1;
        }
        const L2 = this.helper.toNumber(load.L2);
        if (L2 <= 0) {
          startPosition -= L2;
        }
      }
      return startPosition;
    };

    // L2（載荷する部材の長さ）の計算部分
    const calculateTotalLength = (loads: LLLoad[]): number => {
      let totalLength = 0;
      const m1 = Math.abs(parseInt(loads[0].m1));
      let m2 = Math.abs(parseInt(loads[0].m2));
      if (m2 === 0) m2 = m1;
      
      for (let j = m1; j <= m2; j++) {
        totalLength += Math.round(this.member.getMemberLength(j.toString()) * 1000);
      }
      return totalLength / 1000;
    };

    // 計算実行
    const startPosition = calculateStartPosition(loads);
    const totalLength = calculateTotalLength(loads);
    
    const result: LLPositionResult = {
      startPosition: -startPosition,  // スタート位置は負の値
      totalLength: totalLength        // 最大長さ
    };

    // 結果をキャッシュに保存
    this.positionCache.set(cacheKey, result);
    
    return result;
  }

  /**
   * 位置計算のキャッシュをクリア
   */
  public clearPositionCache(): void {
    this.positionCache.clear();
  }

  /**
   * 特定のケースのキャッシュを削除
   */
  public clearPositionCacheForCase(caseId: string): void {
    const keysToDelete = Array.from(this.positionCache.keys())
      .filter(key => key.includes(caseId));
    
    keysToDelete.forEach(key => this.positionCache.delete(key));
  }

  private generateCacheKey(loads: LLLoad[]): string {
    // 荷重データの主要な要素からキャッシュキーを生成
    const keyElements = loads.map(load => 
      `${load.m1}-${load.m2}-${load.L1}-${load.L2}`
    ).join('|');
    
    return `ll_position_${keyElements}`;
  }
}
```

### 3.7 モジュール分割とテスト改善

- 連行移動荷重機能を独立したモジュールとして実装
- 依存性注入を活用して、テスト容易性を向上させる
- 単体テストの充実

```typescript
// src/app/modules/ll-load/ll-load.module.ts
@NgModule({
  declarations: [
    InputLLLoadComponent,
    // その他の関連コンポーネント
  ],
  imports: [
    CommonModule,
    // 必要なモジュール
  ],
  providers: [
    LLLoadService,
    LoadAnimationService,
    // その他の関連サービス
  ],
  exports: [
    InputLLLoadComponent,
    // エクスポートするコンポーネント
  ]
})
export class LLLoadModule { }
```

## 4. 実装計画

リファクタリングは以下のフェーズに分けて実施します：

### フェーズ1: 準備作業（1週間）
- 既存コードの詳細分析
- 現状の処理フローの文書化
- リファクタリングの詳細計画策定
- テスト環境の構築

### フェーズ2: コア機能の実装（2週間）
- `LLLoadService` の実装
  - `calculateLLPosition` メソッドの実装（`get_LL_position` の改善版）
  - `generateLLLoadCases` メソッドの実装（荷重ケース生成）
  - シンボル判定メソッド `isLLLoad` の実装
  - ピッチ検証メソッド `validatePitch` の実装
- データ構造の定義と実装（`ll-load.types.ts`）
- 位置計算のキャッシュ機能実装

### フェーズ3: アニメーション処理とUI改善（1週間）
- `LLAnimationService` の実装
  - RxJSベースのアニメーション処理
  - 従来型アニメーション（requestAnimationFrame）のサポート
  - アニメーション状態管理
- `InputLLLoadComponent` の実装
  - `onPitchChange` メソッドの実装（`change_pich` の改善版）
  - アニメーション制御UI
  - 連行移動荷重設定の専用コンポーネント化

### フェーズ4: 三次元表示システム統合（1週間）
- `LLThreeIntegrationService` の実装
  - `ThreeLoadService` と `ThreeDisplacementService` の処理統合
  - アニメーション処理の委譲
  - レンダリング最適化

### フェーズ5: パフォーマンス最適化（1週間）
- オブジェクトプーリングの実装
- レンダリング処理の最適化
- パフォーマンステスト
- 位置計算キャッシュの最適化

### フェーズ6: テストと統合（1週間）
- 単体テストの実装
  - `LLLoadService` のテスト
  - `LLAnimationService` のテスト
  - 位置計算ロジックのテスト
- 結合テスト
  - 三次元表示との連携テスト
  - アニメーション処理のテスト
- 既存機能との互換性確認
  - 既存の連行移動荷重データの読み込みテスト
  - UI操作の互換性確認

## 5. リスクと対策

| リスク | 影響 | 対策 |
|--------|------|------|
| 既存機能との互換性問題 | 高 | フェーズごとに互換性テストを実施、問題があれば早期に対応 |
| パフォーマンス低下 | 中 | パフォーマンス計測を継続的に実施、ボトルネックを特定して改善 |
| 開発期間の延長 | 中 | 優先順位を明確にし、コア機能から順に実装、必要に応じて計画を調整 |
| リソース不足 | 低 | 事前に必要なリソースを確保、外部リソースの活用も検討 |
| 三次元表示との連携不具合 | 高 | 三次元表示システムとの結合テストを重点的に実施、アニメーション処理の検証を徹底 |

## 6. まとめ

連行移動荷重機能のリファクタリングにより、以下の改善が期待できます：

### 6.1 コード品質の向上
1. **責務分離の明確化**: 連行移動荷重専用の `LLLoadService` により、機能が集約され保守性が向上
2. **型安全性の向上**: 詳細な型定義（`LLLoad`, `LLLoadConfiguration` など）により、バグの発生を減少
3. **命名規則の統一**: `change_pich` → `onPitchChange` など、適切な命名による可読性向上

### 6.2 機能性の向上
4. **アニメーション処理の統一**: `LLAnimationService` により、荷重表示と変位表示のアニメーションが統一
5. **UI/UXの改善**: 専用コンポーネント化により、アニメーション制御やピッチ設定が直感的に操作可能
6. **三次元表示との連携強化**: `LLThreeIntegrationService` により、表示処理が最適化

### 6.3 パフォーマンスの向上
7. **位置計算の最適化**: キャッシュ機能により、同一条件での再計算を回避
8. **レンダリング最適化**: オブジェクトプーリングと差分更新により、大量荷重ケースでも快適に動作
9. **メモリ使用量の削減**: 不要なオブジェクト生成・破棄を最小限に抑制

### 6.4 開発効率の向上
10. **テスト容易性の向上**: 機能分離により、単体テストと結合テストが実装しやすく
11. **拡張性の向上**: 統一されたシンボル判定処理により、新しい荷重タイプの追加が容易
12. **デバッグ効率の向上**: 明確な責務分離により、問題の特定と修正が迅速に

### 6.5 互換性の確保
13. **既存データとの互換性**: `LoadNameWithLL` 型により、既存の `load_name` 構造との互換性を維持
14. **段階的移行**: 従来型アニメーション（`startLegacyAnimation`）のサポートにより、段階的な移行が可能

本リファクタリングは、現状のβ版機能を安定版へと進化させる重要なステップとなり、将来的な機能拡張の基盤を提供します。特に、橋梁解析や移動荷重解析における実用性が大幅に向上することが期待されます。 