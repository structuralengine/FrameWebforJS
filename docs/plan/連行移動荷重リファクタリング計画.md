# 連行移動荷重リファクタリング計画書

## 1. 概要

本計画書は、連行移動荷重（LL: Linear Load）機能のリファクタリングについて記載しています。
現状のコードでは連行移動荷重の処理が複数のサービスに分散しており、責務の分離が明確でないため、
コードの保守性と拡張性を向上させることを目的としています。

## 2. 現状の問題点

現在の連行移動荷重機能には以下の問題点があります：

1. **コードの分散**
   - 連行移動荷重の処理が複数のサービスに分散している
   - 機能が特定のクラスに集約されておらず、既存のサービス内に混在している
   - 特に、表示処理が `ThreeLoadService` と `ThreeDisplacementService` の両方に実装されている

2. **データ構造の不明確さ**
   - 連行移動荷重のデータ構造が明確に型定義されていない
   - `any` 型が多用されており、型安全性が低い
   - `load_name` オブジェクトに `LL_pitch` プロパティが含まれているが、連行移動荷重専用のモデルとの関係が明確でない

3. **パフォーマンスの問題**
   - 連行移動荷重計算時に毎回全ての荷重を削除して再作成している
   - 大量の荷重ケースを生成するとパフォーマンスが低下する可能性がある
   - アニメーション処理が効率的に実装されていない

4. **テスト困難性**
   - 機能が複数のサービスに分散しているため、単体テストが困難
   - 依存関係が複雑で結合度が高い

5. **シンボル判定処理の重複**
   - 連行移動荷重の識別が `symbol.includes("LL")` のような文字列判定で複数箇所に分散している
   - 判定方法が統一されておらず、変更時の影響範囲が広い

6. **三次元表示システムとの連携が複雑**
   - 連行移動荷重の表示処理が複数のサービスに分散している
   - アニメーション処理が異なる方法で実装されている

## 3. リファクタリング提案

### 3.1 クラス分割と責務の明確化

- 連行移動荷重専用の新しいサービスクラス `LLLoadService` を作成し、関連ロジックを集約する
- 既存のサービスから連行移動荷重関連のメソッドを移動させる

```typescript
// src/app/components/input/input-load/ll-load.service.ts を新規作成
import { Injectable } from "@angular/core";
import { InputMembersService } from "../input-members/input-members.service";
import { DataHelperModule } from "../../../providers/data-helper.module";

@Injectable({
  providedIn: "root",
})
export class LLLoadService {
  constructor(
    private member: InputMembersService,
    private helper: DataHelperModule
  ) {}

  // InputLoadServiceから移動させるメソッド
  public get_LL_position(load1: any[]): LLPositionResult {
    // 既存のコードをここに移動して型安全に
    // ...
  }

  // ThreeLoadServiceから移動させるメソッド
  public change_LL_Load(id: string, memberData: object, nodeData: object): LLLoadResult {
    // 既存のコードをここに移動し、修正する
    // ...
  }

  // ThreeDisplacementServiceから移動させるメソッド
  public change_LL_Load_Displacement(id: string, membKeys: string[], minDistance: number, maxDistance: number): void {
    // ThreeDisplacementServiceのchange_LL_Loadメソッドを移動
    // ...
  }

  // シンボル判定メソッドを集約
  public isLLLoad(symbol: string): boolean {
    return symbol.includes("LL");
  }

  // その他の連行移動荷重関連メソッドをここに集約する
}
```

### 3.2 データ構造の改善

- 連行移動荷重に関する型定義を作成する
- データ構造をより明示的に定義する
- 既存の`load_name`オブジェクトとの互換性を確保する

```typescript
// 連行移動荷重に関する型定義
export interface LLLoadDefinition {
  id: string;
  pitch: number;        // 既存のload_name.LL_pitchに対応
  startPosition: number;
  totalLength: number;
  loadCases: LLLoadCase[];
}

export interface LLLoadCase {
  caseId: string;
  position: number;
  loads: LLLoad[]; // 既存の荷重データ構造を使用
}

export interface LLLoad {
  m1: string;
  m2: string;
  direction: string;
  mark: string;
  L1: number;
  L2: number;
  P1: number;
  P2: number;
  // その他の必要なプロパティ
}

// 位置計算結果の型定義
export interface LLPositionResult {
  L1: number;      // スタート位置
  LL_length: number; // 最大長さ
}

// 荷重計算結果の型定義
export interface LLLoadResult {
  loadCases: string[];
  memberKeys: string[];
  // その他の必要なプロパティ
}
```

### 3.3 アニメーション処理の改善

- アニメーション処理を独立したクラスに分離する
- RxJSの利用でアニメーションをストリーム処理として実装する
- ThreeLoadServiceとThreeDisplacementServiceのアニメーション処理を統一する

```typescript
// アニメーション処理専用のサービス
import { Injectable } from "@angular/core";
import { Observable, BehaviorSubject, timer } from "rxjs";
import { map, takeWhile } from "rxjs/operators";

@Injectable({
  providedIn: "root",
})
export class LoadAnimationService {
  private animationSubject = new BehaviorSubject<number>(0);
  private animationActive = false;

  public startAnimation(
    loadCases: string[],
    duration: number = 5000,
    frameRate: number = 30
  ): Observable<string> {
    this.animationActive = true;
    const frames = duration / (1000 / frameRate);
    
    return timer(0, 1000 / frameRate).pipe(
      map(frame => {
        const index = Math.floor((frame % frames) / (frames / loadCases.length));
        this.animationSubject.next(index);
        return loadCases[index];
      }),
      takeWhile(() => this.animationActive)
    );
  }

  public stopAnimation(): void {
    this.animationActive = false;
  }

  // ThreeLoadServiceとThreeDisplacementServiceのanimationメソッドを統一
  public animationWithRenderer(
    keys: string[],
    data: any,
    renderCallback: (key: string) => void,
    i: number = 0,
    old_j: number = 0
  ): void {
    // 既存のアニメーションロジックを改善して実装
    // ...
  }
}
```

### 3.4 連行移動荷重のUI改善

- 既存の機能（ピッチ設定のみ）を維持しながら、コードを整理する
- 連行移動荷重設定部分をコンポーネント化して再利用性を高める
- 入力バリデーション処理を統一する

```typescript
// src/app/components/input/input-ll-load/input-ll-load.component.ts
@Component({
  selector: "app-input-ll-load",
  templateUrl: "./input-ll-load.component.html",
  styleUrls: ["./input-ll-load.component.scss"],
})
export class InputLLLoadComponent implements OnInit {
  @Input() caseId: string;
  @Input() pitch: number = 0.1;
  @Output() pitchChange = new EventEmitter<number>();

  constructor(private llLoadService: LLLoadService) {}

  onPitchChange(): void {
    // ピッチの最小値チェック（現状のinput-load.component.tsのchange_pichと同様）
    if (this.pitch < 0.1) {
      this.pitch = 0.1;
    }
    this.pitchChange.emit(this.pitch);
  }

  // 既存のcheckLLメソッドを改善
  public checkIsLLLoad(symbol: string): boolean {
    return this.llLoadService.isLLLoad(symbol);
  }
}
```

```html
<!-- src/app/components/input/input-ll-load/input-ll-load.component.html -->
<div class="LL_area">
  <label class="label">連行荷重（β版）</label>
  <label class="label">ピッチ</label>
  <input type="number" min="0.1" step="0.1" matInput matType="number" 
         (change)="onPitchChange()" class="input" [(ngModel)]="pitch">
  <label class="label">m</label>
</div>
```

### 3.5 パフォーマンス最適化

- オブジェクトプーリングを実装して、Three.jsのオブジェクト生成・破棄を最小限に抑える
- 必要な部分のみ更新する差分更新方式を採用する
- 計算結果のキャッシュ機能を追加する

```typescript
// オブジェクトプーリングの実装例
class LoadObjectPool {
  private pool: Map<string, THREE.Object3D[]> = new Map();

  public getObject(type: string): THREE.Object3D {
    if (!this.pool.has(type)) {
      this.pool.set(type, []);
    }
    
    const objects = this.pool.get(type);
    if (objects.length > 0) {
      return objects.pop();
    } else {
      return this.createNewObject(type);
    }
  }

  public returnObject(type: string, object: THREE.Object3D): void {
    object.visible = false;
    if (!this.pool.has(type)) {
      this.pool.set(type, []);
    }
    this.pool.get(type).push(object);
  }

  private createNewObject(type: string): THREE.Object3D {
    // 種類に応じたオブジェクト生成ロジック
    // ...
  }
}
```

### 3.6 位置計算処理の改善

- `input-load.service.ts`の`get_LL_position`メソッドを最適化する
- 荷重の長さ(L1)と載荷する部材の長さ(L2)の計算を明確に分離する
- 計算結果のキャッシュ機能を追加する

```typescript
export class LLLoadService {
  // ... 他のメソッド ...

  // InputLoadServiceのget_LL_positionメソッドを改善
  public get_LL_position(load1: LLLoad[]): LLPositionResult {
    // L1の計算部分
    const calculateL1 = (loads: LLLoad[]): number => {
      let L1 = 0;
      for(const load of loads) {
        const loadL1 = this.helper.toNumber(load.L1);
        if(loadL1 <= 0) {
          L1 -= loadL1;
        }
        if(load.L2 <= 0) {
          L1 -= load.L2;
        }
      }
      return L1;
    };

    // L2（載荷する部材の長さ）の計算部分
    const calculateL2 = (loads: LLLoad[]): number => {
      let L2 = 0;
      const m1 = Math.abs(parseInt(loads[0].m1));
      let m2 = Math.abs(parseInt(loads[0].m2));
      if(m2 === 0) m2 = m1;
      
      for (let j = m1; j <= m2; j++) {
        L2 += Math.round(this.member.getMemberLength(j.toString()) * 1000);
      }
      return L2 / 1000;
    };

    // 計算実行
    const L1 = calculateL1(load1);
    const L2 = calculateL2(load1);
    
    return {
      L1: -L1,      // スタート位置は -L1
      LL_length: L2 // 最大長さは L2
    };
  }
}
```

### 3.7 モジュール分割とテスト改善

- 連行移動荷重機能を独立したモジュールとして実装
- 依存性注入を活用して、テスト容易性を向上させる
- 単体テストの充実

```typescript
// src/app/modules/ll-load/ll-load.module.ts
@NgModule({
  declarations: [
    InputLLLoadComponent,
    // その他の関連コンポーネント
  ],
  imports: [
    CommonModule,
    // 必要なモジュール
  ],
  providers: [
    LLLoadService,
    LoadAnimationService,
    // その他の関連サービス
  ],
  exports: [
    InputLLLoadComponent,
    // エクスポートするコンポーネント
  ]
})
export class LLLoadModule { }
```

## 4. 実装計画

リファクタリングは以下のフェーズに分けて実施します：

### フェーズ1: 準備作業（1週間）
- 既存コードの詳細分析
- 現状の処理フローの文書化
- リファクタリングの詳細計画策定
- テスト環境の構築

### フェーズ2: コア機能の実装（2週間）
- `LLLoadService` の実装
  - `get_LL_position` メソッドの移行と改善
  - `change_LL_Load` メソッドの移行と統合（ThreeLoadServiceとThreeDisplacementServiceの両方から）
  - シンボル判定メソッド `isLLLoad` の実装
- データ構造の定義と実装
- 既存コードからの機能移行

### フェーズ3: UI改善とアニメーション処理（1週間）
- `InputLLLoadComponent` の実装
  - `change_pich` メソッドの移行と改善
  - `checkLL` メソッドの移行と改善
- `LoadAnimationService` の実装
  - 両サービスのアニメーション処理の統一
- 既存UIとの連携

### フェーズ4: パフォーマンス最適化（1週間）
- オブジェクトプーリングの実装
- レンダリング処理の最適化
- パフォーマンステスト
- キャッシュ機能の実装

### フェーズ5: テストと統合（1週間）
- 単体テストの実装
- 結合テスト
- 既存機能との互換性確認

## 5. リスクと対策

| リスク | 影響 | 対策 |
|--------|------|------|
| 既存機能との互換性問題 | 高 | フェーズごとに互換性テストを実施、問題があれば早期に対応 |
| パフォーマンス低下 | 中 | パフォーマンス計測を継続的に実施、ボトルネックを特定して改善 |
| 開発期間の延長 | 中 | 優先順位を明確にし、コア機能から順に実装、必要に応じて計画を調整 |
| リソース不足 | 低 | 事前に必要なリソースを確保、外部リソースの活用も検討 |
| 三次元表示との連携不具合 | 高 | 三次元表示システムとの結合テストを重点的に実施、アニメーション処理の検証を徹底 |

## 6. まとめ

連行移動荷重機能のリファクタリングにより、以下の改善が期待できます：

1. コードの責務分離が明確になり、保守性が向上する
2. 型安全性が高まり、バグの発生を減らせる
3. パフォーマンスが向上し、多数の連行移動荷重でも快適に動作する
4. テスト容易性が向上し、品質保証がしやすくなる
5. 三次元表示システムとの連携が改善され、アニメーション表示が安定する
6. シンボル判定処理が統一され、機能の拡張性が向上する

本リファクタリングは、現状のβ版機能を安定版へと進化させる重要なステップとなります。 